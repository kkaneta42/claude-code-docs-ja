> ## Documentation Index
> Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt
> Use this file to discover all available pages before exploring further.

# Claude Code のベストプラクティス

> 環境設定から並列セッションでのスケーリングまで、Claude Code を最大限に活用するためのヒントとパターン。

Claude Code は agentic coding 環境です。質問に答えて待つチャットボットとは異なり、Claude Code はファイルを読み取り、コマンドを実行し、変更を加え、あなたが見守ったり、方向を変えたり、完全に任せたりしながら、自律的に問題を解決できます。

これはあなたの作業方法を変えます。自分でコードを書いて Claude にレビューしてもらう代わりに、やりたいことを説明すると Claude がそれをどのように構築するかを考え出します。Claude は探索し、計画し、実装します。

しかし、この自律性にも学習曲線があります。Claude は理解する必要がある特定の制約の中で動作します。

このガイドでは、Anthropic の内部チームと様々なコードベース、言語、環境で Claude Code を使用しているエンジニアの間で効果的であることが証明されたパターンについて説明します。agentic ループがどのように機能するかについては、[Claude Code の仕組み](/ja/how-claude-code-works)を参照してください。

***

ほとんどのベストプラクティスは 1 つの制約に基づいています。Claude のコンテキストウィンドウはすぐにいっぱいになり、満杯になるにつれてパフォーマンスが低下します。

Claude のコンテキストウィンドウは、すべてのメッセージ、Claude が読み取ったすべてのファイル、すべてのコマンド出力を含む、会話全体を保持します。ただし、これはすぐにいっぱいになる可能性があります。単一のデバッグセッションまたはコードベース探索でも、数万トークンが生成および消費される可能性があります。

これは重要です。LLM のパフォーマンスはコンテキストが満杯になるにつれて低下するためです。コンテキストウィンドウがいっぱいになりかけると、Claude は以前の指示を「忘れる」か、より多くの間違いを犯す可能性があります。コンテキストウィンドウは管理する最も重要なリソースです。トークン使用量を削減するための詳細な戦略については、[トークン使用量を削減する](/ja/costs#reduce-token-usage)を参照してください。

***

## Claude に自分の作業を検証する方法を与える

<Tip>
  Claude が自分自身をチェックできるように、テスト、スクリーンショット、または期待される出力を含めます。これはあなたができる最も高いレバレッジのことです。
</Tip>

Claude は、テストを実行したり、スクリーンショットを比較したり、出力を検証したりするなど、自分の作業を検証できるときにはるかに優れたパフォーマンスを発揮します。

明確な成功基準がないと、正しく見えるが実際には機能しないものを生成する可能性があります。あなたが唯一のフィードバックループになり、すべての間違いがあなたの注意を必要とします。

| 戦略                  | 前                        | 後                                                                                                                                                      |
| ------------------- | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **検証基準を提供する**       | *「メールアドレスを検証する関数を実装する」*  | *「validateEmail 関数を書く。テストケースの例：[user@example.com](mailto:user@example.com) は true、invalid は false、[user@.com](mailto:user@.com) は false。実装後にテストを実行する」* |
| **UI の変更を視覚的に検証する** | *「ダッシュボードをより良く見えるようにする」* | *「\[スクリーンショットを貼り付け] このデザインを実装する。結果のスクリーンショットを撮り、元のものと比較する。違いをリストアップして修正する」*                                                                            |
| **症状ではなく根本原因に対処する** | *「ビルドが失敗している」*           | *「ビルドがこのエラーで失敗している：\[エラーを貼り付け]。修正してビルドが成功することを確認する。エラーを抑制するのではなく、根本原因に対処する」*                                                                           |

UI の変更は [Chrome 拡張機能の Claude](/ja/chrome) を使用して検証できます。これはブラウザで新しいタブを開き、UI をテストし、コードが機能するまで反復します。

検証はテストスイート、リンター、または出力をチェックする Bash コマンドにすることもできます。検証を堅牢にすることに投資してください。

***

## 最初に探索し、次に計画し、その後コーディングする

<Tip>
  間違った問題を解決することを避けるために、研究と計画を実装から分離します。
</Tip>

Claude が直接コーディングにジャンプさせると、間違った問題を解決するコードが生成される可能性があります。[Plan Mode](/ja/common-workflows#use-plan-mode-for-safe-code-analysis) を使用して、探索を実行から分離します。

推奨されるワークフローには 4 つのフェーズがあります。

<Steps>
  <Step title="探索">
    Plan Mode に入ります。Claude はファイルを読み取り、変更を加えずに質問に答えます。

    ```txt claude (Plan Mode) theme={null}
    /src/auth を読み取り、セッションとログインの処理方法を理解する。
    また、シークレットの環境変数の管理方法も確認する。
    ```
  </Step>

  <Step title="計画">
    Claude に詳細な実装計画を作成するよう依頼します。

    ```txt claude (Plan Mode) theme={null}
    Google OAuth を追加したいです。どのファイルを変更する必要がありますか？
    セッションフローは何ですか？計画を作成してください。
    ```

    `Ctrl+G` を押して、Claude が進む前に、テキストエディタで計画を開いて直接編集します。
  </Step>

  <Step title="実装">
    Normal Mode に戻り、Claude にコーディングさせ、計画に対して検証します。

    ```txt claude (Normal Mode) theme={null}
    計画から OAuth フローを実装する。コールバックハンドラーのテストを書き、
    テストスイートを実行して、失敗を修正する。
    ```
  </Step>

  <Step title="コミット">
    Claude に説明的なメッセージでコミットし、PR を作成するよう依頼します。

    ```txt claude (Normal Mode) theme={null}
    説明的なメッセージでコミットして、PR を開く
    ```
  </Step>
</Steps>

<Callout>
  Plan Mode は便利ですが、オーバーヘッドも追加します。

  スコープが明確で修正が小さいタスク（タイプミスの修正、ログ行の追加、変数の名前変更など）の場合は、Claude に直接実行するよう依頼します。

  計画は、アプローチについて不確実な場合、変更が複数のファイルを変更する場合、または変更されるコードに不慣れな場合に最も役立ちます。差分を 1 文で説明できる場合は、計画をスキップします。
</Callout>

***

## プロンプトで具体的なコンテキストを提供する

<Tip>
  指示がより正確であるほど、必要な修正が少なくなります。
</Tip>

Claude は意図を推測できますが、あなたの心を読むことはできません。特定のファイルを参照し、制約を述べ、例のパターンを指摘します。

| 戦略                                          | 前                                              | 後                                                                                                                                                                             |
| ------------------------------------------- | ---------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **タスクをスコープする。** どのファイル、どのシナリオ、テスト設定を指定します。  | *「foo.py のテストを追加する」*                           | *「ユーザーがログアウトしているエッジケースをカバーする foo.py のテストを書く。モックを避ける。」*                                                                                                                        |
| **ソースを指摘する。** Claude を質問に答えることができるソースに向けます。 | *「ExecutionFactory はなぜそんな奇妙な API を持っているのですか？」* | *「ExecutionFactory の git 履歴を調べて、その API がどのようになったかを要約する」*                                                                                                                      |
| **既存のパターンを参照する。** Claude をコードベースのパターンに向けます。 | *「カレンダーウィジェットを追加する」*                           | *「ホームページで既存のウィジェットがどのように実装されているかを見て、パターンを理解する。HotDogWidget.php は良い例です。パターンに従って、ユーザーが月を選択し、前後にページネーションして年を選択できる新しいカレンダーウィジェットを実装する。コードベースで既に使用されているもの以外のライブラリを使用せずにゼロから構築する。」* |
| **症状を説明する。** 症状、可能性のある場所、「修正」の外観を提供します。     | *「ログインバグを修正する」*                                | *「ユーザーはセッションタイムアウト後にログインが失敗すると報告しています。src/auth/ の認証フロー、特にトークンリフレッシュを確認します。問題を再現する失敗するテストを書き、その後修正する」*                                                                         |

曖昧なプロンプトは、探索していて方向転換を余裕を持ってできるときに役立つことがあります。「このファイルで何を改善しますか？」のようなプロンプトは、尋ねることを考えなかったことを表面化させることができます。

### リッチコンテンツを提供する

<Tip>
  `@` を使用してファイルを参照したり、スクリーンショット/画像を貼り付けたり、データを直接パイプしたりします。
</Tip>

Claude にリッチデータを提供する方法はいくつかあります。

* **`@` でファイルを参照する** コードがどこにあるかを説明する代わりに。Claude は応答する前にファイルを読み取ります。
* **画像を直接貼り付ける**。画像をコピー/貼り付けまたはドラッグアンドドロップしてプロンプトに入れます。
* **ドキュメントと API リファレンスの URL を指定する**。`/permissions` を使用して、頻繁に使用されるドメインをホワイトリストに登録します。
* **データをパイプする** `cat error.log | claude` を実行してファイルの内容を直接送信します。
* **Claude に必要なものを取得させる**。Bash コマンド、MCP ツール、またはファイルを読み取ることを使用して、Claude にコンテキストを自分で引き出すよう指示します。

***

## 環境を設定する

いくつかのセットアップステップにより、Claude Code はすべてのセッションで大幅に効果的になります。拡張機能の完全な概要と各機能をいつ使用するかについては、[Claude Code を拡張する](/ja/features-overview)を参照してください。

### 効果的な CLAUDE.md を書く

<Tip>
  `/init` を実行して、現在のプロジェクト構造に基づいてスターター CLAUDE.md ファイルを生成し、時間をかけて改善します。
</Tip>

CLAUDE.md は Claude がすべての会話の開始時に読む特別なファイルです。Bash コマンド、コードスタイル、ワークフロールールを含めます。これにより、Claude に、コードだけからは推測できない永続的なコンテキストが与えられます。

`/init` コマンドはコードベースを分析してビルドシステム、テストフレームワーク、コードパターンを検出し、改善するための堅牢な基盤を提供します。

CLAUDE.md ファイルに必須の形式はありませんが、短く人間が読める状態に保ちます。例えば：

```markdown CLAUDE.md theme={null}
# コードスタイル
- ES モジュール（import/export）構文を使用する。CommonJS（require）は使用しない
- 可能な場合は import をデストラクチャリングする（例：import { foo } from 'bar'）

# ワークフロー
- 一連のコード変更を行った後は、必ずタイプチェックを実行する
- テストスイート全体ではなく、単一のテストを実行することを優先する（パフォーマンスのため）
```

CLAUDE.md はすべてのセッションで読み込まれるため、広く適用されるもののみを含めます。ドメイン知識またはときどきのみ関連するワークフローについては、代わりに [skills](/ja/skills) を使用します。Claude はそれらをオンデマンドで読み込み、すべての会話を膨らませることなく使用します。

簡潔に保ちます。各行について、次のように尋ねます。*「これを削除すると Claude が間違いを犯しますか？」* そうでない場合は、削除します。膨らんだ CLAUDE.md ファイルは Claude に実際の指示を無視させます。

| ✅ 含める                     | ❌ 除外する                           |
| ------------------------- | -------------------------------- |
| Claude が推測できない Bash コマンド  | Claude がコードを読むことで理解できるもの         |
| デフォルトと異なるコードスタイルルール       | Claude が既に知っている標準言語規約            |
| テスト指示と優先テストランナー           | 詳細な API ドキュメント（代わりにドキュメントにリンクする） |
| リポジトリのエチケット（ブランチ命名、PR 規約） | 頻繁に変わる情報                         |
| プロジェクト固有のアーキテクチャ決定        | 長い説明またはチュートリアル                   |
| 開発者環境の癖（必須環境変数）           | ファイルごとのコードベースの説明                 |
| 一般的な落とし穴または明らかでない動作       | 「きれいなコードを書く」のような自明なプラクティス        |

Claude が CLAUDE.md にルールがあるにもかかわらず、あなたが望まないことをし続ける場合、ファイルはおそらく長すぎて、ルールが失われています。Claude が CLAUDE.md で答えられている質問をあなたに尋ねる場合、表現が曖昧かもしれません。CLAUDE.md をコードのように扱う：物事がうまくいかないときにレビューし、定期的に削除し、Claude の動作が実際に変わるかどうかを観察して変更をテストします。

指示の遵守を改善するために、強調（例：「重要」または「必須」）を追加することで指示を調整できます。CLAUDE.md を git にチェックインして、チームが貢献できるようにします。ファイルは時間とともに価値が複合します。

CLAUDE.md ファイルは `@path/to/import` 構文を使用して追加ファイルをインポートできます。

```markdown CLAUDE.md theme={null}
プロジェクト概要については @README.md を、利用可能な npm コマンドについては @package.json を参照してください。

# 追加指示
- Git ワークフロー：@docs/git-instructions.md
- 個人的なオーバーライド：@~/.claude/my-project-instructions.md
```

CLAUDE.md ファイルはいくつかの場所に配置できます。

* **ホームフォルダ（`~/.claude/CLAUDE.md`）**：すべての Claude セッションに適用されます
* **プロジェクトルート（`./CLAUDE.md`）**：git にチェックインしてチームと共有するか、`CLAUDE.local.md` という名前を付けて `.gitignore` に入れます
* **親ディレクトリ**：`root/CLAUDE.md` と `root/foo/CLAUDE.md` の両方が自動的に取得されるモノレポに役立ちます
* **子ディレクトリ**：Claude がそれらのディレクトリ内のファイルを操作するときに、Claude は子 CLAUDE.md ファイルをオンデマンドで取得します

### パーミッションを設定する

<Tip>
  `/permissions` を使用して安全なコマンドをホワイトリストに登録するか、`/sandbox` を使用して OS レベルの分離を行います。これにより、中断が減り、制御が保たれます。
</Tip>

デフォルトでは、Claude Code はシステムを変更する可能性のあるアクション（ファイル書き込み、Bash コマンド、MCP ツールなど）のパーミッションをリクエストします。これは安全ですが、面倒です。10 回目の承認後、あなたは本当にレビューしていません。単にクリックしているだけです。これらの中断を減らす方法は 2 つあります。

* **パーミッションホワイトリスト**：安全であることがわかっている特定のツール（`npm run lint` や `git commit` など）を許可します
* **サンドボックス**：OS レベルの分離を有効にして、ファイルシステムとネットワークアクセスを制限し、Claude が定義された境界内でより自由に動作できるようにします

または、`--dangerously-skip-permissions` を使用して、lint エラーの修正やボイラープレートの生成などの含まれたワークフローのすべてのパーミッションチェックをバイパスします。

<Warning>
  Claude に任意のコマンドを実行させると、データ損失、システム破損、またはプロンプトインジェクションによるデータ流出が発生する可能性があります。`--dangerously-skip-permissions` はインターネットアクセスのないサンドボックスでのみ使用してください。
</Warning>

[パーミッションの設定](/ja/settings)と [サンドボックスの有効化](/ja/sandboxing#sandboxing)の詳細をお読みください。

### CLI ツールを使用する

<Tip>
  Claude Code に `gh`、`aws`、`gcloud`、`sentry-cli` などの CLI ツールを使用して外部サービスと対話するよう指示します。
</Tip>

CLI ツールは外部サービスと対話する最もコンテキスト効率的な方法です。GitHub を使用する場合は、`gh` CLI をインストールします。Claude は問題の作成、プルリクエストのオープン、コメントの読み取りにそれを使用する方法を知っています。`gh` がなければ、Claude は GitHub API を使用できますが、認証されていないリクエストはしばしばレート制限に達します。

Claude は既に知らない CLI ツールの学習にも効果的です。`Use 'foo-cli-tool --help' to learn about foo tool, then use it to solve A, B, C.` のようなプロンプトを試してください。

### MCP サーバーを接続する

<Tip>
  `claude mcp add` を実行して、Notion、Figma、またはデータベースなどの外部ツールを接続します。
</Tip>

[MCP サーバー](/ja/mcp)を使用すると、Claude に問題トラッカーから機能を実装したり、データベースをクエリしたり、監視データを分析したり、Figma からデザインを統合したり、ワークフローを自動化するよう依頼できます。

### フックを設定する

<Tip>
  例外なく毎回実行する必要があるアクションにはフックを使用します。
</Tip>

[フック](/ja/hooks-guide)は Claude のワークフロー内の特定のポイントで自動的にスクリプトを実行します。CLAUDE.md の指示は勧告的ですが、フックは決定的で、アクションが確実に実行されることを保証します。

Claude はあなたのためにフックを書くことができます。*「すべてのファイル編集後に eslint を実行するフックを書く」* または *「migrations フォルダへの書き込みをブロックするフック」* のようなプロンプトを試してください。`/hooks` を実行して対話的に設定するか、`.claude/settings.json` を直接編集します。

### スキルを作成する

<Tip>
  `.claude/skills/` に `SKILL.md` ファイルを作成して、Claude にドメイン知識と再利用可能なワークフローを提供します。
</Tip>

[スキル](/ja/skills)は、プロジェクト、チーム、またはドメイン固有の情報で Claude の知識を拡張します。Claude は関連するときに自動的にそれらを適用するか、`/skill-name` で直接呼び出すことができます。

`.claude/skills/` に `SKILL.md` を含むディレクトリを追加してスキルを作成します。

```markdown .claude/skills/api-conventions/SKILL.md theme={null}
---
name: api-conventions
description: サービスの REST API 設計規約
---
# API 規約
- URL パスに kebab-case を使用する
- JSON プロパティに camelCase を使用する
- リストエンドポイントには常にページネーションを含める
- URL パスで API をバージョン管理する（/v1/、/v2/）
```

スキルは直接呼び出す再利用可能なワークフローを定義することもできます。

```markdown .claude/skills/fix-issue/SKILL.md theme={null}
---
name: fix-issue
description: GitHub の問題を修正する
disable-model-invocation: true
---
GitHub の問題を分析して修正する：$ARGUMENTS。

1. `gh issue view` を使用して問題の詳細を取得する
2. 問題で説明されている問題を理解する
3. 関連ファイルのコードベースを検索する
4. 問題を修正するために必要な変更を実装する
5. 修正を検証するためのテストを書いて実行する
6. コードがリントとタイプチェックに合格することを確認する
7. 説明的なコミットメッセージを作成する
8. プッシュして PR を作成する
```

`/fix-issue 1234` を実行して呼び出します。副作用のあるワークフローに `disable-model-invocation: true` を使用して、手動でトリガーしたいものに使用します。

### カスタムサブエージェントを作成する

<Tip>
  `.claude/agents/` に特化したアシスタントを定義して、Claude が分離されたタスクに委譲できるようにします。
</Tip>

[サブエージェント](/ja/sub-agents)は独自のコンテキストと独自の許可されたツールセットで実行されます。多くのファイルを読み取る必要があるタスクや、メイン会話を乱さずに特化したフォーカスが必要なタスクに役立ちます。

```markdown .claude/agents/security-reviewer.md theme={null}
---
name: security-reviewer
description: セキュリティの脆弱性についてコードをレビューする
tools: Read, Grep, Glob, Bash
model: opus
---
あなたはシニアセキュリティエンジニアです。コードを以下についてレビューする：
- インジェクション脆弱性（SQL、XSS、コマンドインジェクション）
- 認証と認可の欠陥
- コード内のシークレットまたは認証情報
- 不安全なデータ処理

特定の行参照と提案される修正を提供する。
```

Claude にサブエージェントを明示的に使用するよう指示する：*「サブエージェントを使用してこのコードをセキュリティの問題についてレビューする。」*

### プラグインをインストールする

<Tip>
  `/plugin` を実行してマーケットプレイスを参照します。プラグインは設定なしでスキル、ツール、統合を追加します。
</Tip>

[プラグイン](/ja/plugins)は、スキル、フック、サブエージェント、MCP サーバーをコミュニティと Anthropic からの単一のインストール可能なユニットにバンドルします。型付き言語を使用する場合は、[コード インテリジェンス プラグイン](/ja/discover-plugins#code-intelligence)をインストールして、Claude に正確なシンボルナビゲーションと編集後の自動エラー検出を提供します。

スキル、サブエージェント、フック、MCP の間で選択するためのガイダンスについては、[Claude Code を拡張する](/ja/features-overview#match-features-to-your-goal)を参照してください。

***

## 効果的にコミュニケーションを取る

Claude Code との通信方法は、結果の品質に大きく影響します。

### コードベースの質問をする

<Tip>
  シニアエンジニアに尋ねるような質問を Claude にしてください。
</Tip>

新しいコードベースにオンボーディングするときは、Claude Code を学習と探索に使用します。別のエンジニアに尋ねるのと同じ種類の質問を Claude に尋ねることができます。

* ログはどのように機能しますか？
* 新しい API エンドポイントを作成するにはどうすればよいですか？
* `foo.rs` の 134 行目の `async move { ... }` は何をしますか？
* `CustomerOnboardingFlowImpl` はどのエッジケースを処理しますか？
* このコードが `foo.rs` の 333 行目で `bar()` の代わりに `foo()` を呼び出すのはなぜですか？

Claude Code をこのように使用することは、効果的なオンボーディングワークフローであり、ラップアップ時間を改善し、他のエンジニアの負荷を軽減します。特別なプロンプトは必要ありません。直接質問してください。

### Claude にあなたにインタビューさせる

<Tip>
  より大きな機能については、Claude に最初にあなたにインタビューさせます。最小限のプロンプトで始めて、Claude に `AskUserQuestion` ツールを使用してあなたにインタビューするよう依頼します。
</Tip>

Claude は、技術的な実装、UI/UX、エッジケース、トレードオフなど、まだ考えていないことについて質問します。

```
[簡潔な説明] を構築したいです。AskUserQuestion ツールを使用して詳細にインタビューしてください。

技術的な実装、UI/UX、エッジケース、懸念事項、トレードオフについて質問してください。明らかな質問をしないでください。考えていない難しい部分を掘り下げてください。

すべてをカバーするまでインタビューを続けてから、完全な仕様を SPEC.md に書き込みます。
```

仕様が完成したら、新しいセッションを開始して実行します。新しいセッションはクリーンなコンテキストを持ち、実装に完全に焦点を当てており、参照する書面による仕様があります。

***

## セッションを管理する

会話は永続的で可逆的です。これを有利に使用してください。

### 早期かつ頻繁に方向転換する

<Tip>
  Claude が軌道を外れていることに気付いたらすぐに修正してください。
</Tip>

最良の結果は、タイトなフィードバックループから来ます。Claude は時々最初の試みで問題を完全に解決しますが、迅速に修正することは一般的により良いソリューションをより速く生成します。

* **`Esc`**：`Esc` キーで Claude の途中のアクションを停止します。コンテキストは保持されるため、リダイレクトできます。
* **`Esc + Esc` または `/rewind`**：`Esc` を 2 回押すか、`/rewind` を実行して巻き戻しメニューを開き、以前の会話とコード状態を復元します。
* **`"Undo that"`**：Claude に変更を元に戻すよう依頼します。
* **`/clear`**：関連のないタスク間でコンテキストをリセットします。関連のないコンテキストを含む長いセッションはパフォーマンスを低下させる可能性があります。

1 つのセッションで同じ問題について 2 回以上 Claude を修正した場合、コンテキストは失敗したアプローチで乱雑になっています。`/clear` を実行し、学んだことを組み込んだより具体的なプロンプトで新しく開始します。クリーンなセッションとより良いプロンプトは、蓄積された修正を含む長いセッションをほぼ常に上回ります。

### コンテキストを積極的に管理する

<Tip>
  関連のないタスク間でコンテキストをリセットするために `/ clear` を頻繁に実行します。
</Tip>

Claude Code はコンテキスト制限に近づくと、会話履歴を自動的にコンパクトにします。これにより、重要なコードと決定が保持されながら、スペースが解放されます。

長いセッション中、Claude のコンテキストウィンドウは関連のない会話、ファイルの内容、コマンドで満杯になる可能性があります。これはパフォーマンスを低下させ、時々 Claude を気を散らすことができます。

* 関連のないタスク間で頻繁に `/clear` を使用してコンテキストウィンドウを完全にリセットします
* 自動コンパクションがトリガーされると、Claude は最も重要なもの（コードパターン、ファイル状態、主要な決定を含む）を要約します
* より多くの制御のために、`/compact <instructions>` を実行します。例えば `/compact Focus on the API changes`
* CLAUDE.md でコンパクション動作をカスタマイズして、`"When compacting, always preserve the full list of modified files and any test commands"` のような指示を使用して、重要なコンテキストが要約を生き残ることを確認します

### 調査にサブエージェントを使用する

<Tip>
  `"use subagents to investigate X"` でリサーチを委譲します。彼らは別のコンテキストで探索し、メイン会話を実装用にクリーンに保ちます。
</Tip>

コンテキストが基本的な制約であるため、サブエージェントは利用可能な最も強力なツールの 1 つです。Claude がコードベースを研究するとき、多くのファイルを読み取り、すべてがコンテキストを消費します。サブエージェントは別のコンテキストウィンドウで実行され、要約を報告します。

```
認証システムがトークンリフレッシュをどのように処理するか、
および再利用すべき既存の OAuth ユーティリティがあるかどうかを調査するために
サブエージェントを使用します。
```

サブエージェントはコードベースを探索し、関連ファイルを読み取り、メイン会話を乱さずにすべての結果を報告します。

Claude が何かを実装した後の検証にサブエージェントを使用することもできます。

```
サブエージェントを使用してこのコードをエッジケースについてレビューする
```

### チェックポイントで巻き戻す

<Tip>
  Claude が行うすべてのアクションはチェックポイントを作成します。以前のチェックポイントに会話、コード、またはその両方を復元できます。
</Tip>

Claude は変更前に自動的にチェックポイントを作成します。`Escape` をダブルタップするか、`/rewind` を実行してチェックポイントメニューを開きます。会話のみを復元（コード変更を保持）、コードのみを復元（会話を保持）、または両方を復元できます。

慎重にすべての動きを計画する代わりに、Claude に何か危険なことを試すよう指示できます。うまくいかない場合は、巻き戻して別のアプローチを試してください。チェックポイントはセッション間で永続するため、ターミナルを閉じてもまだ後で巻き戻すことができます。

<Warning>
  チェックポイントは Claude が行った変更のみを追跡します。外部プロセスではありません。これは git の代替ではありません。
</Warning>

### 会話を再開する

<Tip>
  `claude --continue` を実行して中断したところから再開するか、`--resume` を実行して最近のセッションから選択します。
</Tip>

Claude Code はローカルに会話を保存します。タスクが複数のセッションにまたがる場合（機能を開始し、中断され、翌日戻ってくる）、コンテキストを再度説明する必要はありません。

```bash  theme={null}
claude --continue    # 最新の会話を再開する
claude --resume      # 最近の会話から選択する
```

`/rename` を使用してセッションに説明的な名前を付けます（`"oauth-migration"`、`"debugging-memory-leak"`）。後で見つけやすくします。セッションをブランチのように扱います。異なるワークストリームは別の永続的なコンテキストを持つことができます。

***

## 自動化とスケール

1 つの Claude で効果的になったら、並列セッション、ヘッドレスモード、ファンアウトパターンで出力を乗算します。

これまでのすべては、1 人の人間、1 つの Claude、1 つの会話を想定しています。しかし、Claude Code は水平にスケールします。このセクションのテクニックは、より多くを達成する方法を示しています。

### ヘッドレスモードを実行する

<Tip>
  CI、プリコミットフック、またはスクリプトで `claude -p "prompt"` を使用します。ストリーミング JSON 出力の場合は `--output-format stream-json` を追加します。
</Tip>

`claude -p "your prompt"` を使用すると、対話的なセッションなしでヘッドレスで Claude を実行できます。ヘッドレスモードは Claude を CI パイプライン、プリコミットフック、または自動ワークフローに統合する方法です。出力形式（プレーンテキスト、JSON、ストリーミング JSON）により、結果をプログラムで解析できます。

```bash  theme={null}
# ワンオフクエリ
claude -p "このプロジェクトが何をするかを説明する"

# スクリプト用の構造化出力
claude -p "すべての API エンドポイントをリストアップする" --output-format json

# リアルタイム処理用のストリーミング
claude -p "このログファイルを分析する" --output-format stream-json
```

### 複数の Claude セッションを実行する

<Tip>
  複数の Claude セッションを並列で実行して、開発を高速化し、分離された実験を実行するか、複雑なワークフローを開始します。
</Tip>

並列セッションを実行する主な方法は 2 つあります。

* [Claude Desktop](/ja/desktop)：複数のローカルセッションを視覚的に管理します。各セッションは独自の分離されたワークツリーを取得します。
* [Web 上の Claude Code](/ja/claude-code-on-the-web)：Anthropic のセキュアなクラウドインフラストラクチャで分離された VM で実行します。

作業を並列化することを超えて、複数のセッションは品質に焦点を当てたワークフローを有効にします。新しいコンテキストは、Claude がちょうど書いたコードに偏らないため、コードレビューを改善します。

例えば、Writer/Reviewer パターンを使用します。

| セッション A（ライター）                                   | セッション B（レビュアー）                                                                      |
| ----------------------------------------------- | ----------------------------------------------------------------------------------- |
| `API エンドポイントのレート制限を実装する`                        |                                                                                     |
|                                                 | `@src/middleware/rateLimiter.ts のレート制限実装をレビューする。エッジケース、競合状態、既存のミドルウェアパターンとの一貫性を探す。` |
| `レビューフィードバックは以下の通りです：[セッション B 出力]。これらの問題に対処する。` |                                                                                     |

テストで同様のことを行うことができます。1 つの Claude にテストを書かせ、別の Claude にそれらを渡すコードを書かせます。

### ファイル全体でファンアウトする

<Tip>
  各タスクに対して `claude -p` を呼び出すループを実行します。バッチ操作の場合は `--allowedTools` を使用してパーミッションをスコープします。
</Tip>

大規模な移行または分析の場合、多くの並列 Claude 呼び出し全体で作業を配布できます。

<Steps>
  <Step title="タスクリストを生成する">
    Claude に移行が必要なすべてのファイルをリストアップさせます（例：`移行が必要な 2,000 個の Python ファイルをすべてリストアップする`）
  </Step>

  <Step title="リストをループするスクリプトを書く">
    ```bash  theme={null}
    for file in $(cat files.txt); do
      claude -p "React から Vue に $file を移行する。OK または FAIL を返す。" \
        --allowedTools "Edit,Bash(git commit *)"
    done
    ```
  </Step>

  <Step title="いくつかのファイルでテストしてから、スケールで実行する">
    最初の 2～3 ファイルで何が悪いかに基づいてプロンプトを改善してから、完全なセットで実行します。`--allowedTools` フラグは Claude が何ができるかを制限し、無人で実行しているときに重要です。
  </Step>
</Steps>

Claude を既存のデータ/処理パイプラインに統合することもできます。

```bash  theme={null}
claude -p "<your prompt>" --output-format json | your_command
```

開発中はデバッグに `--verbose` を使用し、本番環境ではオフにします。

### 安全な自律モード

`claude --dangerously-skip-permissions` を使用してすべてのパーミッションチェックをバイパスし、Claude が中断されずに動作できるようにします。これは lint エラーの修正やボイラープレートコードの生成などのワークフローに適しています。

<Warning>
  Claude に任意のコマンドを実行させることはリスクがあり、データ損失、システム破損、またはデータ流出（例えば、プロンプトインジェクション攻撃を介して）が発生する可能性があります。これらのリスクを最小化するには、インターネットアクセスのないコンテナで `--dangerously-skip-permissions` を使用してください。

  サンドボックスが有効な場合（`/sandbox`）、同様の自律性が得られますが、セキュリティが向上します。サンドボックスはすべてのチェックをバイパスするのではなく、事前に境界を定義します。
</Warning>

***

## 一般的な失敗パターンを避ける

これらは一般的な間違いです。早期に認識することで時間を節約できます。

* **キッチンシンクセッション。** 1 つのタスクで開始し、Claude に関連のないことを尋ねてから、最初のタスクに戻ります。コンテキストは関連のない情報でいっぱいです。
  > **修正**：関連のないタスク間で `/clear` を実行します。
* **何度も修正する。** Claude が何か間違ったことをし、修正し、まだ間違っています。修正します。コンテキストは失敗したアプローチで汚染されています。
  > **修正**：2 回の失敗した修正の後、`/clear` を実行し、学んだことを組み込んだより良い初期プロンプトを書きます。
* **過度に指定された CLAUDE.md。** CLAUDE.md が長すぎる場合、Claude は重要なルールがノイズに失われるため、半分を無視します。
  > **修正**：容赦なく削除します。Claude が指示なしで既に何かを正しく行っている場合は、削除するか、フックに変換します。
* **信頼してから検証するギャップ。** Claude は、エッジケースを処理しない、もっともらしく見える実装を生成します。
  > **修正**：常に検証を提供します（テスト、スクリプト、スクリーンショット）。検証できない場合は、出荷しないでください。
* **無限探索。** スコープなしで何かを「調査」するよう Claude に依頼します。Claude は数百のファイルを読み取り、コンテキストを満杯にします。
  > **修正**：調査を狭くスコープするか、サブエージェントを使用して、探索がメインコンテキストを消費しないようにします。

***

## 直感を開発する

このガイドのパターンは固定されていません。それらは一般的にうまく機能する出発点ですが、すべての状況に最適ではない可能性があります。

時々、コンテキストが蓄積する必要があります。なぜなら、あなたは 1 つの複雑な問題に深く入り込んでおり、履歴は価値があるからです。時々、計画をスキップして Claude に理解させるべきです。なぜなら、タスクは探索的だからです。時々、曖昧なプロンプトは正確です。なぜなら、Claude が問題を解釈する方法を見たいからです。

何が機能するかに注意を払ってください。Claude が素晴らしい出力を生成するとき、あなたが何をしたかに注意してください。プロンプト構造、提供したコンテキスト、あなたがいたモード。Claude が苦労するとき、なぜ尋ねてください。コンテキストがノイズが多すぎましたか？プロンプトが曖昧すぎましたか？タスクが 1 回のパスには大きすぎましたか？

時間をかけて、ガイドが捉えることができない直感を開発します。いつ具体的にするか、いつ開放的にするか、いつ計画するか、いつ探索するか、いつコンテキストをクリアするか、いつ蓄積させるかを知ります。

## 関連リソース

<CardGroup cols={2}>
  <Card title="Claude Code の仕組み" icon="gear" href="/ja/how-claude-code-works">
    agentic ループ、ツール、コンテキスト管理を理解する
  </Card>

  <Card title="Claude Code を拡張する" icon="puzzle-piece" href="/ja/features-overview">
    スキル、フック、MCP、サブエージェント、プラグインの間で選択する
  </Card>

  <Card title="一般的なワークフロー" icon="list-check" href="/ja/common-workflows">
    デバッグ、テスト、PR などのステップバイステップレシピ
  </Card>

  <Card title="CLAUDE.md" icon="file-lines" href="/ja/memory">
    プロジェクト規約と永続的なコンテキストを保存する
  </Card>
</CardGroup>
