> ## Documentation Index
> Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt
> Use this file to discover all available pages before exploring further.

# カスタムサブエージェントの作成

> Claude Codeでタスク固有のワークフローと改善されたコンテキスト管理のための特化したAIサブエージェントを作成して使用します。

サブエージェントは、特定の種類のタスクを処理する特化したAIアシスタントです。各サブエージェントは、カスタムシステムプロンプト、特定のツールアクセス、および独立した権限を持つ独自のコンテキストウィンドウで実行されます。Claudeがサブエージェントの説明に一致するタスクに遭遇すると、そのサブエージェントに委譲され、サブエージェントは独立して動作し、結果を返します。

サブエージェントは以下の点で役立ちます：

* **コンテキストを保持する** - 探索と実装をメインの会話から分離することで
* **制約を強制する** - サブエージェントが使用できるツールを制限することで
* **設定を再利用する** - ユーザーレベルのサブエージェントでプロジェクト全体で
* **動作を特化させる** - 特定のドメイン向けの焦点を絞ったシステムプロンプトで
* **コストを制御する** - Haikuのような高速で安価なモデルにタスクをルーティングすることで

Claudeは各サブエージェントの説明を使用して、タスクを委譲するかどうかを決定します。サブエージェントを作成するときは、Claudeがいつそれを使用するかを知るように明確な説明を書いてください。

Claude Codeには、**Explore**、**Plan**、**general-purpose**などのいくつかの組み込みサブエージェントが含まれています。特定のタスクを処理するためのカスタムサブエージェントを作成することもできます。このページでは、[組み込みサブエージェント](#built-in-subagents)、[独自のサブエージェントの作成方法](#quickstart-create-your-first-subagent)、[完全な設定オプション](#configure-subagents)、[サブエージェントの使用パターン](#work-with-subagents)、および[サブエージェントの例](#example-subagents)について説明します。

## 組み込みサブエージェント

Claude Codeには、Claudeが適切なときに自動的に使用する組み込みサブエージェントが含まれています。各サブエージェントは、親の会話の権限を継承し、追加のツール制限があります。

<Tabs>
  <Tab title="Explore">
    コードベースの検索と分析に最適化された高速で読み取り専用のエージェント。

    * **モデル**: Haiku（高速、低レイテンシ）
    * **ツール**: 読み取り専用ツール（WriteおよびEditツールへのアクセスは拒否）
    * **目的**: ファイル検出、コード検索、コードベース探索

    Claudeは、変更を加えずにコードベースを検索または理解する必要があるときにExploreに委譲します。これにより、探索結果がメインの会話コンテキストから除外されます。

    Exploreを呼び出すとき、Claudeは徹底度レベルを指定します：ターゲット検索には**quick**、バランスの取れた探索には**medium**、包括的な分析には**very thorough**。
  </Tab>

  <Tab title="Plan">
    [プランモード](/ja/common-workflows#use-plan-mode-for-safe-code-analysis)中にプランを提示する前にコンテキストを収集するために使用される研究エージェント。

    * **モデル**: メイン会話から継承
    * **ツール**: 読み取り専用ツール（WriteおよびEditツールへのアクセスは拒否）
    * **目的**: 計画のためのコードベース研究

    プランモード中にClaudeがコードベースを理解する必要がある場合、研究をPlanサブエージェントに委譲します。これにより、無限ネストを防ぎながら（サブエージェントは他のサブエージェントを生成できません）、必要なコンテキストを収集します。
  </Tab>

  <Tab title="General-purpose">
    探索とアクションの両方を必要とする複雑なマルチステップタスク用の有能なエージェント。

    * **モデル**: メイン会話から継承
    * **ツール**: すべてのツール
    * **目的**: 複雑な研究、マルチステップ操作、コード変更

    Claudeは、タスクが探索と変更の両方を必要とする場合、結果を解釈するための複雑な推論が必要な場合、または複数の依存ステップがある場合にgeneral-purposeに委譲します。
  </Tab>

  <Tab title="Other">
    Claude Codeには、特定のタスク用の追加のヘルパーエージェントが含まれています。これらは通常自動的に呼び出されるため、直接使用する必要はありません。

    | エージェント            | モデル    | Claudeが使用するとき                     |
    | :---------------- | :----- | :-------------------------------- |
    | Bash              | 継承     | 別のコンテキストでターミナルコマンドを実行するとき         |
    | statusline-setup  | Sonnet | `/statusline`を実行してステータスラインを設定するとき |
    | Claude Code Guide | Haiku  | Claude Code機能について質問するとき           |
  </Tab>
</Tabs>

これらの組み込みサブエージェントを超えて、カスタムプロンプト、ツール制限、権限モード、フック、およびスキルを備えた独自のサブエージェントを作成できます。次のセクションでは、開始方法とサブエージェントのカスタマイズ方法を示します。

## クイックスタート：最初のサブエージェントを作成する

サブエージェントはYAMLフロントマター付きのMarkdownファイルで定義されます。[手動で作成](#write-subagent-files)することも、`/agents`コマンドを使用することもできます。

このチュートリアルでは、`/agent`コマンドを使用してユーザーレベルのサブエージェントを作成するプロセスを説明します。サブエージェントはコードをレビューし、コードベースの改善を提案します。

<Steps>
  <Step title="サブエージェントインターフェースを開く">
    Claude Codeで、以下を実行します：

    ```
    /agents
    ```
  </Step>

  <Step title="新しいユーザーレベルエージェントを作成する">
    **Create new agent**を選択し、**User-level**を選択します。これにより、サブエージェントが`~/.claude/agents/`に保存され、すべてのプロジェクトで利用可能になります。
  </Step>

  <Step title="Claudeで生成する">
    **Generate with Claude**を選択します。プロンプトが表示されたら、サブエージェントを説明します：

    ```
    ファイルをスキャンして、可読性、パフォーマンス、およびベストプラクティスの改善を提案するコード改善エージェント。各問題を説明し、現在のコードを表示し、改善されたバージョンを提供する必要があります。
    ```

    Claudeはシステムプロンプトと設定を生成します。カスタマイズしたい場合は、`e`を押してエディタで開きます。
  </Step>

  <Step title="ツールを選択する">
    読み取り専用レビュアーの場合、**Read-only tools**以外のすべてを選択解除します。すべてのツールを選択したままにすると、サブエージェントはメイン会話で利用可能なすべてのツールを継承します。
  </Step>

  <Step title="モデルを選択する">
    サブエージェントが使用するモデルを選択します。このサンプルエージェントの場合、コードパターンの分析のために機能と速度のバランスを取る**Sonnet**を選択します。
  </Step>

  <Step title="色を選択する">
    サブエージェントの背景色を選択します。これにより、UIでどのサブエージェントが実行されているかを識別するのに役立ちます。
  </Step>

  <Step title="保存して試す">
    サブエージェントを保存します。すぐに利用可能になります（再起動は不要）。試してみてください：

    ```
    code-improverエージェントを使用して、このプロジェクトの改善を提案してください
    ```

    Claudeは新しいサブエージェントに委譲し、コードベースをスキャンして改善提案を返します。
  </Step>
</Steps>

これで、マシン上のあらゆるプロジェクトでコードベースを分析し、改善を提案するために使用できるサブエージェントができました。

サブエージェントはMarkdownファイルとして手動で作成したり、CLIフラグを使用して定義したり、プラグインを通じて配布したりすることもできます。次のセクションでは、すべての設定オプションについて説明します。

## サブエージェントの設定

### /agentsコマンドを使用する

`/agents`コマンドは、サブエージェントを管理するためのインタラクティブインターフェースを提供します。`/agents`を実行して以下を行います：

* すべての利用可能なサブエージェント（組み込み、ユーザー、プロジェクト、プラグイン）を表示する
* ガイド付きセットアップまたはClaude生成で新しいサブエージェントを作成する
* 既存のサブエージェント設定とツールアクセスを編集する
* カスタムサブエージェントを削除する
* 重複が存在する場合、どのサブエージェントがアクティブであるかを確認する

これはサブエージェントを作成および管理するための推奨される方法です。手動作成または自動化の場合、サブエージェントファイルを直接追加することもできます。

### サブエージェントのスコープを選択する

サブエージェントはYAMLフロントマター付きのMarkdownファイルです。スコープに応じて異なる場所に保存します。複数のサブエージェントが同じ名前を共有する場合、優先度が高い場所が優先されます。

| 場所                    | スコープ        | 優先度   | 作成方法                        |
| :-------------------- | :---------- | :---- | :-------------------------- |
| `--agents` CLIフラグ     | 現在のセッション    | 1（最高） | Claude Code起動時にJSONを渡す      |
| `.claude/agents/`     | 現在のプロジェクト   | 2     | インタラクティブまたは手動               |
| `~/.claude/agents/`   | すべてのプロジェクト  | 3     | インタラクティブまたは手動               |
| プラグインの`agents/`ディレクトリ | プラグインが有効な場所 | 4（最低） | [プラグイン](/ja/plugins)でインストール |

**プロジェクトサブエージェント**（`.claude/agents/`）は、コードベース固有のサブエージェントに最適です。バージョン管理にチェックインして、チームが協力して使用および改善できるようにします。

**ユーザーサブエージェント**（`~/.claude/agents/`）は、すべてのプロジェクトで利用可能な個人用サブエージェントです。

**CLI定義サブエージェント**は、Claude Code起動時にJSONとして渡されます。そのセッションのみ存在し、ディスクに保存されないため、クイックテストまたは自動化スクリプトに役立ちます：

```bash  theme={null}
claude --agents '{
  "code-reviewer": {
    "description": "エキスパートコードレビュアー。コード変更後に積極的に使用してください。",
    "prompt": "あなたはシニアコードレビュアーです。コード品質、セキュリティ、およびベストプラクティスに焦点を当ててください。",
    "tools": ["Read", "Grep", "Glob", "Bash"],
    "model": "sonnet"
  }
}'
```

`--agents`フラグは、[フロントマター](#supported-frontmatter-fields)と同じフィールドを持つJSONを受け入れます。ファイルベースのサブエージェントのmarkdownボディと同等のシステムプロンプトに`prompt`を使用します。完全なJSON形式については、[CLIリファレンス](/ja/cli-reference#agents-flag-format)を参照してください。

**プラグインサブエージェント**は、インストールした[プラグイン](/ja/plugins)から提供されます。カスタムサブエージェントと一緒に`/agents`に表示されます。プラグインサブエージェントの作成の詳細については、[プラグインコンポーネントリファレンス](/ja/plugins-reference#agents)を参照してください。

### サブエージェントファイルを書く

サブエージェントファイルは、設定用のYAMLフロントマターの後にMarkdownのシステムプロンプトを使用します：

<Note>
  サブエージェントはセッション開始時に読み込まれます。ファイルを手動で追加してサブエージェントを作成する場合、セッションを再起動するか、`/agents`を使用してすぐに読み込みます。
</Note>

```markdown  theme={null}
---
name: code-reviewer
description: コード品質とベストプラクティスのレビュー
tools: Read, Glob, Grep
model: sonnet
---

あなたはコードレビュアーです。呼び出されたときは、コードを分析し、品質、セキュリティ、およびベストプラクティスに関する具体的で実行可能なフィードバックを提供してください。
```

フロントマターはサブエージェントのメタデータと設定を定義します。ボディはサブエージェントの動作をガイドするシステムプロンプトになります。サブエージェントは、このシステムプロンプトのみを受け取ります（作業ディレクトリなどの基本的な環境詳細を含む）、完全なClaude Codeシステムプロンプトではありません。

#### サポートされているフロントマターフィールド

YAMLフロントマターで使用できる以下のフィールド。`name`と`description`のみが必須です。

| フィールド             | 必須  | 説明                                                                                                                    |
| :---------------- | :-- | :-------------------------------------------------------------------------------------------------------------------- |
| `name`            | はい  | 小文字と連字符を使用した一意の識別子                                                                                                    |
| `description`     | はい  | Claudeがこのサブエージェントに委譲するべき時                                                                                             |
| `tools`           | いいえ | サブエージェントが使用できる[ツール](#available-tools)。省略された場合はすべてのツールを継承                                                              |
| `disallowedTools` | いいえ | 拒否するツール、継承または指定されたリストから削除                                                                                             |
| `model`           | いいえ | 使用する[モデル](#choose-a-model)：`sonnet`、`opus`、`haiku`、または`inherit`。デフォルトは`sonnet`                                        |
| `permissionMode`  | いいえ | [権限モード](#permission-modes)：`default`、`acceptEdits`、`dontAsk`、`bypassPermissions`、または`plan`                            |
| `skills`          | いいえ | スタートアップ時にサブエージェントのコンテキストに読み込む[スキル](/ja/skills)。完全なスキルコンテンツが注入され、呼び出しのためだけに利用可能にされるわけではありません。サブエージェントは親の会話からスキルを継承しません |
| `hooks`           | いいえ | このサブエージェントにスコープされた[ライフサイクルフック](#define-hooks-for-subagents)                                                           |

### モデルを選択する

`model`フィールドは、サブエージェントが使用する[AIモデル](/ja/model-config)を制御します：

* **モデルエイリアス**: 利用可能なエイリアスの1つを使用します：`sonnet`、`opus`、または`haiku`
* **inherit**: メイン会話と同じモデルを使用します（一貫性に役立ちます）
* **省略**: 指定されていない場合、サブエージェント用に設定されたデフォルトモデル（`sonnet`）を使用します

### サブエージェントの機能を制御する

ツールアクセス、権限モード、および条件付きルールを通じて、サブエージェントが何ができるかを制御できます。

#### 利用可能なツール

サブエージェントは、Claude Codeの[内部ツール](/ja/settings#tools-available-to-claude)のいずれかを使用できます。デフォルトでは、サブエージェントはMCPツールを含む、メイン会話から利用可能なすべてのツールを継承します。

ツールを制限するには、`tools`フィールド（許可リスト）または`disallowedTools`フィールド（拒否リスト）を使用します：

```yaml  theme={null}
---
name: safe-researcher
description: 制限された機能を持つ研究エージェント
tools: Read, Grep, Glob, Bash
disallowedTools: Write, Edit
---
```

#### 権限モード

`permissionMode`フィールドは、サブエージェントが権限プロンプトをどのように処理するかを制御します。サブエージェントはメイン会話から権限コンテキストを継承しますが、モードをオーバーライドできます。

| モード                 | 動作                                |
| :------------------ | :-------------------------------- |
| `default`           | プロンプト付きの標準権限チェック                  |
| `acceptEdits`       | ファイル編集を自動受け入れ                     |
| `dontAsk`           | 権限プロンプトを自動拒否（明示的に許可されたツールは引き続き機能） |
| `bypassPermissions` | すべての権限チェックをスキップ                   |
| `plan`              | プランモード（読み取り専用探索）                  |

<Warning>
  `bypassPermissions`は注意して使用してください。すべての権限チェックをスキップし、サブエージェントが承認なしに任意の操作を実行できるようにします。
</Warning>

親が`bypassPermissions`を使用する場合、これが優先され、オーバーライドできません。

#### スキルをサブエージェントにプリロードする

`skills`フィールドを使用して、スキルコンテンツをスタートアップ時にサブエージェントのコンテキストに注入します。これにより、実行中にスキルを発見して読み込む必要なく、サブエージェントにドメイン知識を提供します。

```yaml  theme={null}
---
name: api-developer
description: チーム規約に従ってAPIエンドポイントを実装する
skills:
  - api-conventions
  - error-handling-patterns
---

APIエンドポイントを実装します。プリロードされたスキルの規約とパターンに従ってください。
```

各スキルの完全なコンテンツがサブエージェントのコンテキストに注入され、呼び出しのためだけに利用可能にされるわけではありません。サブエージェントは親の会話からスキルを継承しません。明示的にリストする必要があります。

<Note>
  これは[サブエージェントでスキルを実行する](/ja/skills#run-skills-in-a-subagent)の逆です。サブエージェント内の`skills`では、サブエージェントがシステムプロンプトを制御し、スキルコンテンツを読み込みます。スキル内の`context: fork`では、スキルコンテンツが指定したエージェントに注入されます。どちらも同じ基盤システムを使用します。
</Note>

#### フックを使用した条件付きルール

ツール使用をより動的に制御するには、`PreToolUse`フックを使用して、実行前に操作を検証します。ツールの一部の操作を許可しながら他の操作をブロックする必要がある場合に役立ちます。

この例は、読み取り専用データベースクエリのみを許可するサブエージェントを作成します。`PreToolUse`フックは、各Bashコマンドが実行される前に`command`で指定されたスクリプトを実行します：

```yaml  theme={null}
---
name: db-reader
description: 読み取り専用データベースクエリを実行する
tools: Bash
hooks:
  PreToolUse:
    - matcher: "Bash"
      hooks:
        - type: command
          command: "./scripts/validate-readonly-query.sh"
---
```

Claude Code [はフック入力をJSON](/ja/hooks#pretooluse-input)として標準入力を通じてフックコマンドに渡します。検証スクリプトはこのJSONを読み取り、Bashコマンドを抽出し、[終了コード2](/ja/hooks#exit-code-2-behavior)で書き込み操作をブロックします：

```bash  theme={null}
#!/bin/bash
# ./scripts/validate-readonly-query.sh

INPUT=$(cat)
COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command // empty')

# SQL書き込み操作をブロック（大文字小文字を区別しない）
if echo "$COMMAND" | grep -iE '\b(INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|TRUNCATE)\b' > /dev/null; then
  echo "ブロック：SELECT クエリのみが許可されています" >&2
  exit 2
fi

exit 0
```

完全な入力スキーマについては[フック入力](/ja/hooks#pretooluse-input)を、終了コードが動作に与える影響については[終了コード](/ja/hooks#simple-exit-code)を参照してください。

#### 特定のサブエージェントを無効にする

[設定](/ja/settings#permission-settings)の`deny`配列に追加することで、Claudeが特定のサブエージェントを使用するのを防ぐことができます。`subagent-name`がサブエージェントの名前フィールドと一致する`Task(subagent-name)`形式を使用します。

```json  theme={null}
{
  "permissions": {
    "deny": ["Task(Explore)", "Task(my-custom-agent)"]
  }
}
```

これは組み込みとカスタムサブエージェントの両方で機能します。`--disallowedTools` CLIフラグを使用することもできます：

```bash  theme={null}
claude --disallowedTools "Task(Explore)"
```

詳細については、[IAMドキュメント](/ja/iam#tool-specific-permission-rules)を参照してください。

### サブエージェント用のフックを定義する

サブエージェントは、サブエージェントのライフサイクル中に実行される[フック](/ja/hooks)を定義できます。フックを設定する方法は2つあります：

1. **サブエージェントのフロントマター内**: そのサブエージェントがアクティブな間のみ実行されるフックを定義
2. **`settings.json`内**: サブエージェントが開始または停止するときにメインセッションで実行されるフックを定義

#### サブエージェントフロントマター内のフック

サブエージェントのmarkdownファイルにフックを直接定義します。これらのフックは、その特定のサブエージェントがアクティブな間のみ実行され、完了時にクリーンアップされます。

| イベント          | マッチャー入力 | 実行時期               |
| :------------ | :------ | :----------------- |
| `PreToolUse`  | ツール名    | サブエージェントがツールを使用する前 |
| `PostToolUse` | ツール名    | サブエージェントがツールを使用した後 |
| `Stop`        | （なし）    | サブエージェントが完了したとき    |

この例は、`PreToolUse`フックでBashコマンドを検証し、`PostToolUse`でファイル編集後にリンターを実行します：

```yaml  theme={null}
---
name: code-reviewer
description: 自動リント付きコード変更をレビュー
hooks:
  PreToolUse:
    - matcher: "Bash"
      hooks:
        - type: command
          command: "./scripts/validate-command.sh $TOOL_INPUT"
  PostToolUse:
    - matcher: "Edit|Write"
      hooks:
        - type: command
          command: "./scripts/run-linter.sh"
---
```

フロントマター内の`Stop`フックは自動的に`SubagentStop`イベントに変換されます。

#### サブエージェントイベント用のプロジェクトレベルフック

メインセッションでサブエージェントのライフサイクルイベントに応答するフックを`settings.json`で設定します。`matcher`フィールドを使用して、名前で特定のエージェントタイプをターゲットにします。

| イベント            | マッチャー入力    | 実行時期               |
| :-------------- | :--------- | :----------------- |
| `SubagentStart` | エージェントタイプ名 | サブエージェントが実行を開始するとき |
| `SubagentStop`  | エージェントタイプ名 | サブエージェントが完了するとき    |

この例は、`db-agent`サブエージェントが開始および停止するときのみセットアップおよびクリーンアップスクリプトを実行します：

```json  theme={null}
{
  "hooks": {
    "SubagentStart": [
      {
        "matcher": "db-agent",
        "hooks": [
          { "type": "command", "command": "./scripts/setup-db-connection.sh" }
        ]
      }
    ],
    "SubagentStop": [
      {
        "matcher": "db-agent",
        "hooks": [
          { "type": "command", "command": "./scripts/cleanup-db-connection.sh" }
        ]
      }
    ]
  }
}
```

完全なフック設定形式については、[フック](/ja/hooks)を参照してください。

## サブエージェントの使用

### 自動委譲を理解する

Claudeは、リクエスト内のタスク説明、サブエージェント設定の`description`フィールド、および現在のコンテキストに基づいて、タスクを自動的に委譲します。積極的な委譲を促進するには、サブエージェントの説明フィールドに「use proactively」などのフレーズを含めます。

特定のサブエージェントを明示的にリクエストすることもできます：

```
test-runnerサブエージェントを使用して失敗したテストを修正してください
code-reviewerサブエージェントに最近の変更を確認させてください
```

### サブエージェントをフォアグラウンドまたはバックグラウンドで実行する

サブエージェントはフォアグラウンド（ブロッキング）またはバックグラウンド（同時実行）で実行できます：

* **フォアグラウンドサブエージェント** - メイン会話が完了するまでブロックします。権限プロンプトと明確化の質問（[`AskUserQuestion`](/ja/settings#tools-available-to-claude)など）はあなたに渡されます。
* **バックグラウンドサブエージェント** - 作業を続けながら同時実行されます。親の権限を継承し、事前に承認されていないものを自動拒否します。バックグラウンドサブエージェントが持っていない権限が必要な場合、または明確化の質問が必要な場合、そのツール呼び出しは失敗しますが、サブエージェントは続行します。MCPツールはバックグラウンドサブエージェントでは利用できません。

バックグラウンドサブエージェントが権限の欠落により失敗した場合、[再開](#resume-subagents)してフォアグラウンドで再試行できます。

Claudeは、タスクに基づいてサブエージェントをフォアグラウンドまたはバックグラウンドで実行するかどうかを決定します。また、以下を行うこともできます：

* Claudeに「これをバックグラウンドで実行してください」と依頼する
* **Ctrl+B**を押して実行中のタスクをバックグラウンド化する

すべてのバックグラウンドタスク機能を無効にするには、`CLAUDE_CODE_DISABLE_BACKGROUND_TASKS`環境変数を`1`に設定します。[環境変数](/ja/settings#environment-variables)を参照してください。

### 一般的なパターン

#### 大量の操作を分離する

サブエージェントの最も効果的な使用法の1つは、大量の出力を生成する操作を分離することです。テストの実行、ドキュメントの取得、またはログファイルの処理は、かなりのコンテキストを消費できます。これらをサブエージェントに委譲することで、詳細な出力はサブエージェントのコンテキストに留まり、関連する要約のみがメイン会話に返されます。

```
サブエージェントを使用してテストスイートを実行し、失敗したテストとそのエラーメッセージのみを報告してください
```

#### 並列研究を実行する

独立した調査の場合、複数のサブエージェントを生成して同時に作業させます：

```
認証、データベース、およびAPIモジュールを並列で調査するために、別々のサブエージェントを使用してください
```

各サブエージェントは独立して領域を探索し、Claudeが結果を統合します。これは研究パスが互いに依存しない場合に最適です。

<Warning>
  サブエージェントが完了すると、その結果がメイン会話に返されます。詳細な結果を返す多くのサブエージェントを実行すると、かなりのコンテキストを消費できます。
</Warning>

#### サブエージェントをチェーンする

マルチステップワークフローの場合、Claudeに順序でサブエージェントを使用するよう依頼します。各サブエージェントはタスクを完了して結果をClaudeに返し、Claudeは関連するコンテキストを次のサブエージェントに渡します。

```
code-reviewerサブエージェントを使用してパフォーマンスの問題を見つけ、次にoptimizerサブエージェントを使用してそれらを修正してください
```

### サブエージェントとメイン会話の選択

**メイン会話**を使用する場合：

* タスクが頻繁なやり取りまたは反復的な改善が必要
* 複数のフェーズが重要なコンテキストを共有する（計画→実装→テスト）
* 迅速でターゲット化された変更を行っている
* レイテンシが重要。サブエージェントは新規に開始し、コンテキストを収集するのに時間がかかる場合があります

**サブエージェント**を使用する場合：

* タスクが詳細な出力を生成し、メインコンテキストに必要ない
* 特定のツール制限または権限を強制したい
* 作業が自己完結型で、要約を返すことができる

代わりに[スキル](/ja/skills)を検討してください。メイン会話コンテキストで実行される分離されたサブエージェントコンテキストではなく、再利用可能なプロンプトまたはワークフローが必要な場合。

<Note>
  サブエージェントは他のサブエージェントを生成できません。ワークフローがネストされた委譲を必要とする場合、[スキル](/ja/skills)を使用するか、メイン会話から[サブエージェントをチェーン](#chain-subagents)します。
</Note>

### サブエージェントコンテキストを管理する

#### サブエージェントを再開する

各サブエージェント呼び出しは、新しいコンテキストで新しいインスタンスを作成します。最初からやり直すのではなく、既存のサブエージェントの作業を続けるには、Claudeに再開するよう依頼します。

再開されたサブエージェントは、すべての前のツール呼び出し、結果、および推論を含む、完全な会話履歴を保持します。サブエージェントは新規に開始するのではなく、停止した場所から正確に再開します。

サブエージェントが完了すると、ClaudeはそのエージェントIDを受け取ります。サブエージェントを再開するには、Claudeに前の作業を続けるよう依頼します：

```
code-reviewerサブエージェントを使用して認証モジュールをレビューしてください
[エージェントが完了]

そのコードレビューを続けて、今度は認可ロジックを分析してください
[Claudeは前の会話から完全なコンテキストでサブエージェントを再開]
```

エージェントIDを参照したい場合はClaudeに依頼することもできます。または、`~/.claude/projects/{project}/{sessionId}/subagents/`のトランスクリプトファイルでIDを見つけることができます。各トランスクリプトは`agent-{agentId}.jsonl`として保存されます。

サブエージェントトランスクリプトはメイン会話から独立して永続化されます：

* **メイン会話圧縮**: メイン会話が圧縮されると、サブエージェントトランスクリプトは影響を受けません。別のファイルに保存されます。
* **セッション永続化**: サブエージェントトランスクリプトはセッション内で永続化されます。同じセッションを再開することで、Claude Code再起動後に[サブエージェントを再開](#resume-subagents)できます。
* **自動クリーンアップ**: トランスクリプトは`cleanupPeriodDays`設定に基づいてクリーンアップされます（デフォルト：30日）。

#### 自動圧縮

サブエージェントは、メイン会話と同じロジックを使用した自動圧縮をサポートしています。デフォルトでは、自動圧縮は約95%の容量でトリガーされます。圧縮を早期にトリガーするには、`CLAUDE_AUTOCOMPACT_PCT_OVERRIDE`をより低いパーセンテージに設定します（例：`50`）。詳細については、[環境変数](/ja/settings#environment-variables)を参照してください。

圧縮イベントはサブエージェントトランスクリプトファイルに記録されます：

```json  theme={null}
{
  "type": "system",
  "subtype": "compact_boundary",
  "compactMetadata": {
    "trigger": "auto",
    "preTokens": 167189
  }
}
```

`preTokens`値は、圧縮が発生する前に使用されたトークン数を示します。

## サブエージェントの例

これらの例は、サブエージェントを構築するための効果的なパターンを示しています。出発点として使用するか、Claudeで生成したカスタマイズされたバージョンを使用します。

<Tip>
  **ベストプラクティス：**

  * **焦点を絞ったサブエージェントを設計する：** 各サブエージェントは1つの特定のタスクに優れている必要があります
  * **詳細な説明を書く：** Claudeは説明を使用して委譲するかどうかを決定します
  * **ツールアクセスを制限する：** セキュリティと焦点のために必要な権限のみを付与します
  * **バージョン管理にチェックインする：** プロジェクトサブエージェントをチームと共有します
</Tip>

### コードレビュアー

コードを変更せずにレビューする読み取り専用サブエージェント。この例は、制限されたツールアクセス（EditおよびWriteなし）と、何を探すべきか、どのように出力をフォーマットするかを正確に指定する詳細なプロンプトを備えた、焦点を絞ったサブエージェントを設計する方法を示しています。

```markdown  theme={null}
---
name: code-reviewer
description: エキスパートコードレビュー専門家。品質、セキュリティ、保守性のためにコードを積極的にレビューします。コードを書いたり変更したりした直後に使用してください。
tools: Read, Grep, Glob, Bash
model: inherit
---

あなたはコード品質とセキュリティの高い基準を確保するシニアコードレビュアーです。

呼び出されたときは：
1. git diffを実行して最近の変更を確認
2. 変更されたファイルに焦点を当てる
3. すぐにレビューを開始

レビューチェックリスト：
- コードは明確で読みやすい
- 関数と変数は適切に命名されている
- 重複したコードはない
- 適切なエラーハンドリング
- 公開されたシークレットまたはAPIキーはない
- 入力検証が実装されている
- 良好なテストカバレッジ
- パフォーマンスの考慮事項に対応している

優先度別に整理されたフィードバックを提供：
- 重大な問題（修正が必須）
- 警告（修正すべき）
- 提案（改善を検討）

問題の修正方法の具体例を含めてください。
```

### デバッガー

問題を分析して修正できるサブエージェント。コードレビュアーとは異なり、バグの修正にはコード変更が必要なため、Editが含まれています。プロンプトは診断から検証までの明確なワークフローを提供します。

```markdown  theme={null}
---
name: debugger
description: エラー、テスト失敗、および予期しない動作のデバッグ専門家。問題が発生したときに積極的に使用してください。
tools: Read, Edit, Bash, Grep, Glob
---

あなたは根本原因分析を専門とするエキスパートデバッガーです。

呼び出されたときは：
1. エラーメッセージとスタックトレースをキャプチャ
2. 再現ステップを特定
3. 失敗の場所を分離
4. 最小限の修正を実装
5. ソリューションが機能することを確認

デバッグプロセス：
- エラーメッセージとログを分析
- 最近のコード変更を確認
- 仮説を形成してテスト
- 戦略的なデバッグログを追加
- 変数の状態を検査

各問題について、以下を提供：
- 根本原因の説明
- 診断を支持する証拠
- 特定のコード修正
- テストアプローチ
- 予防推奨事項

症状ではなく、根本的な問題の修正に焦点を当ててください。
```

### データサイエンティスト

データ分析作業用のドメイン固有のサブエージェント。この例は、典型的なコーディングタスク以外の特化したワークフロー用のサブエージェントを作成する方法を示しています。明示的に`model: sonnet`を設定して、より有能な分析を行います。

```markdown  theme={null}
---
name: data-scientist
description: SQLクエリ、BigQuery操作、およびデータインサイト用のデータ分析エキスパート。データ分析タスクとクエリに積極的に使用してください。
tools: Bash, Read, Write
model: sonnet
---

あなたはSQLおよびBigQuery分析を専門とするデータサイエンティストです。

呼び出されたときは：
1. データ分析要件を理解
2. 効率的なSQLクエリを作成
3. 適切な場合はBigQueryコマンドラインツール（bq）を使用
4. 結果を分析して要約
5. 結果を明確に提示

主要なプラクティス：
- 適切なフィルターを使用した最適化されたSQLクエリを作成
- 適切な集計と結合を使用
- 複雑なロジックを説明するコメントを含める
- 読みやすさのために結果をフォーマット
- データに基づいた推奨事項を提供

各分析について：
- クエリアプローチを説明
- 仮定を文書化
- 主要な結果を強調
- データに基づいた次のステップを提案

クエリが効率的でコスト効果的であることを常に確認してください。
```

### データベースクエリバリデーター

Bashアクセスを許可しますが、読み取り専用SQLクエリのみを許可するようにコマンドを検証するサブエージェント。この例は、`tools`フィールドが提供するよりも細かい制御が必要な場合に、`PreToolUse`フックを使用して条件付き検証を行う方法を示しています。

```markdown  theme={null}
---
name: db-reader
description: 読み取り専用データベースクエリを実行します。データを分析またはレポートを生成するときに使用してください。
tools: Bash
hooks:
  PreToolUse:
    - matcher: "Bash"
      hooks:
        - type: command
          command: "./scripts/validate-readonly-query.sh"
---

あなたは読み取り専用アクセス権を持つデータベースアナリストです。SELECTクエリを実行してデータに関する質問に答えてください。

データを分析するよう求められたときは：
1. 関連データを含むテーブルを特定
2. 適切なフィルターを使用した効率的なSELECTクエリを作成
3. コンテキスト付きで結果を明確に提示

データを変更することはできません。INSERT、UPDATE、DELETE、またはスキーマ変更を依頼された場合、読み取り専用アクセスのみを持っていることを説明してください。
```

Claude Code [はフック入力をJSON](/ja/hooks#pretooluse-input)として標準入力を通じてフックコマンドに渡します。検証スクリプトはこのJSONを読み取り、実行されるコマンドを抽出し、SQLの書き込み操作のリストに対してチェックします。書き込み操作が検出された場合、スクリプトは[終了コード2](/ja/hooks#exit-code-2-behavior)で終了してClaudeに標準エラーを通じてエラーメッセージを返します。

プロジェクト内の任意の場所に検証スクリプトを作成します。パスはフック設定の`command`フィールドと一致する必要があります：

```bash  theme={null}
#!/bin/bash
# SQL書き込み操作をブロック、SELECTクエリを許可

# 標準入力からJSON入力を読み取る
INPUT=$(cat)

# jqを使用してtool_inputからcommandフィールドを抽出
COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command // empty')

if [ -z "$COMMAND" ]; then
  exit 0
fi

# 書き込み操作をブロック（大文字小文字を区別しない）
if echo "$COMMAND" | grep -iE '\b(INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|TRUNCATE|REPLACE|MERGE)\b' > /dev/null; then
  echo "ブロック：書き込み操作は許可されていません。SELECTクエリのみを使用してください。" >&2
  exit 2
fi

exit 0
```

スクリプトを実行可能にします：

```bash  theme={null}
chmod +x ./scripts/validate-readonly-query.sh
```

フックは標準入力を通じてJSONを受け取り、Bashコマンドは`tool_input.command`にあります。終了コード2は操作をブロックし、エラーメッセージをClaudeにフィードバックします。終了コードと動作の詳細については[フック](/ja/hooks#simple-exit-code)を、完全な入力スキーマについては[フック入力](/ja/hooks#pretooluse-input)を参照してください。

## 次のステップ

サブエージェントを理解したので、これらの関連機能を探索してください：

* [プラグインでサブエージェントを配布](/ja/plugins)して、チームまたはプロジェクト全体でサブエージェントを共有
* [Agent SDKでClaudeコードをプログラムで実行](/ja/headless)してCI/CDと自動化を行う
* [MCPサーバーを使用](/ja/mcp)してサブエージェントに外部ツールとデータへのアクセスを提供
